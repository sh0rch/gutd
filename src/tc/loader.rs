//! GUT v1 Protocol - TC/XDP eBPF Fast Path Loader
//!
//! This loader manages eBPF programs for GUT v1 protocol with auto-detection
//! of the best redirect mode:
//!
//! **Level 1**: veth + XDP devmap bulk redirect + native XDP
//!   - Fastest: eliminates TC stage, kernel batches NAPI redirects
//!   - Requires NIC driver with XDP native support
//!
//! **Level 2**: veth + XDP devmap bulk redirect + generic XDP  
//!   - Same devmap benefit, but XDP runs in generic/SKB mode
//!   - When NIC lacks native XDP driver support
//!
//! **Level 3**: TAP + XDP_PASS + TC redirect (fallback)
//!   - Works on any kernel ≥ 5.2
//!   - Two-stage: XDP decap → TC bpf_redirect(TAP, BPF_F_INGRESS)
//!
//! Levels 1-2 use the same BPF program (xdp_gut_ingress_devmap).
//! The kernel auto-selects native vs generic XDP at attach time.
//!
//! Responsibilities:
//! - Create data interface (veth pair or TAP)
//! - Load compiled eBPF .o files (generated by libbpf-cargo in build.rs)
//! - Attach TC hooks: egress (TUN→UDP) and ingress (UDP→TUN)
//! - Initialize BPF maps with GUT v1 config
//! - Read statistics from BPF maps

use crate::config::Config;
use crate::tc::maps::{
    GutConfig, GutStats, DEFAULT_INNER_MTU, GUT_FLAG_NEED_L4_CSUM, OUTER_OVERHEAD_IPV4,
    OUTER_OVERHEAD_IPV6,
};
use crate::Result;
use std::sync::atomic::Ordering;
#[cfg(not(target_has_atomic = "64"))]
use std::sync::Mutex;

#[cfg(target_has_atomic = "64")]
type CounterInner = std::sync::atomic::AtomicU64;
#[cfg(not(target_has_atomic = "64"))]
type CounterInner = Mutex<u64>;

struct CounterU64 {
    inner: CounterInner,
}

impl CounterU64 {
    const fn new(value: u64) -> Self {
        #[cfg(target_has_atomic = "64")]
        {
            Self {
                inner: std::sync::atomic::AtomicU64::new(value),
            }
        }
        #[cfg(not(target_has_atomic = "64"))]
        {
            Self {
                inner: Mutex::new(value),
            }
        }
    }

    fn fetch_add(&self, value: u64, ordering: Ordering) -> u64 {
        #[cfg(target_has_atomic = "64")]
        {
            self.inner.fetch_add(value, ordering)
        }
        #[cfg(not(target_has_atomic = "64"))]
        {
            let _ = ordering;
            let mut guard = self.inner.lock().expect("counter mutex poisoned");
            let old = *guard;
            *guard = old.saturating_add(value);
            old
        }
    }

    fn load(&self, ordering: Ordering) -> u64 {
        #[cfg(target_has_atomic = "64")]
        {
            self.inner.load(ordering)
        }
        #[cfg(not(target_has_atomic = "64"))]
        {
            let _ = ordering;
            *self.inner.lock().expect("counter mutex poisoned")
        }
    }
}

static DROP_POLICY_SAFETY_OVERRIDES: CounterU64 = CounterU64::new(0);

#[must_use]
pub fn drop_policy_safety_overrides() -> u64 {
    DROP_POLICY_SAFETY_OVERRIDES.load(Ordering::Relaxed)
}

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
use std::mem::MaybeUninit;

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
use std::os::fd::AsFd;

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
use libbpf_rs::skel::{OpenSkel, SkelBuilder};

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
use libbpf_rs::{MapCore, MapFlags, TcHookBuilder};

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
#[allow(clippy::all, clippy::pedantic)]
mod tc_gut_egress {
    include!(concat!(env!("OUT_DIR"), "/tc_gut_egress.skel.rs"));
}

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
#[allow(clippy::all, clippy::pedantic)]
mod tc_gut_egress_v6 {
    include!(concat!(env!("OUT_DIR"), "/tc_gut_egress_v6.skel.rs"));
}

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
#[allow(clippy::all, clippy::pedantic)]
mod xdp_gut_ingress {
    include!(concat!(env!("OUT_DIR"), "/xdp_gut_ingress.skel.rs"));
}

/// Egress skeleton: either outer-IPv4 or outer-IPv6 variant.
/// Both compiled from the same source with/without `-DGUT_OUTER_IPV6`.
#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
enum EgressSkel {
    V4(tc_gut_egress::TcGutEgressSkel<'static>),
    V6(tc_gut_egress_v6::TcGutEgressSkel<'static>),
}

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
impl EgressSkel {
    fn update_config_map(&self, gut_config: &GutConfig) -> crate::Result<()> {
        let value = unsafe {
            std::slice::from_raw_parts(
                (gut_config as *const GutConfig).cast::<u8>(),
                std::mem::size_of::<GutConfig>(),
            )
        };
        match self {
            Self::V4(s) => s
                .maps
                .config_map
                .update(&0u32.to_ne_bytes(), value, MapFlags::ANY)?,
            Self::V6(s) => s
                .maps
                .config_map
                .update(&0u32.to_ne_bytes(), value, MapFlags::ANY)?,
        }
        Ok(())
    }

    fn update_counters_map(&self, initial_seq: u32) -> crate::Result<()> {
        let bytes = initial_seq.to_ne_bytes();
        match self {
            Self::V4(s) => {
                s.maps
                    .counters_map
                    .update(&0u32.to_ne_bytes(), &bytes, MapFlags::ANY)?
            }
            Self::V6(s) => {
                s.maps
                    .counters_map
                    .update(&0u32.to_ne_bytes(), &bytes, MapFlags::ANY)?
            }
        }
        Ok(())
    }

    fn gut_egress_fd(&self) -> std::os::fd::BorrowedFd<'_> {
        match self {
            Self::V4(s) => s.progs.gut_egress.as_fd(),
            Self::V6(s) => s.progs.gut_egress.as_fd(),
        }
    }

    fn is_v6(&self) -> bool {
        matches!(self, Self::V6(_))
    }

    fn lookup_stats(
        &self,
        key: &[u8],
    ) -> std::result::Result<Option<Vec<Vec<u8>>>, libbpf_rs::Error> {
        match self {
            Self::V4(s) => s.maps.stats_map.lookup_percpu(key, MapFlags::ANY),
            Self::V6(s) => s.maps.stats_map.lookup_percpu(key, MapFlags::ANY),
        }
    }
}

#[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
pub struct TcBpfManager {
    interface: String,
    ingress_interface: String,
    egress_skel: EgressSkel,
    ingress_skel: xdp_gut_ingress::XdpGutIngressSkel<'static>,
    _egress_hook: libbpf_rs::TcHook,
    _xdp_link: libbpf_rs::Link,
    _veth_pass_link: libbpf_rs::Link,
    _veth_xdp_name: String,
}

#[cfg(not(all(target_os = "linux", feature = "tc_ebpf")))]
pub struct TcBpfManager {
    interface: String,
    ingress_interface: String,
}

#[derive(Debug, Default)]
pub struct TcStats {
    pub egress: GutStats,
    pub ingress: GutStats,
}

#[cfg(target_os = "linux")]
struct RouteGetInfo {
    first_line: String,
    dev: Option<String>,
    via: Option<std::net::IpAddr>,
    src: Option<std::net::IpAddr>,
    mtu: Option<u16>,
}

impl TcBpfManager {
    /// Create veth pair, load and attach all BPF programs.
    ///
    /// Creates veth pair `<ifname>_xdp` ↔ `<ifname>`.
    /// Selects outer-IPv4 or outer-IPv6 egress BPF based on peer address family.
    /// Attaches TC egress on `<ifname>` (encap+mask) and XDP on NIC (decap+unmask+devmap redirect).
    #[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
    pub fn new(ifname: &str, config: &Config) -> Result<Self> {
        let ingress_ifname =
            if let Some(nic) = config.peer().nic.clone().filter(|s| !s.trim().is_empty()) {
                nic
            } else if let Some(peer_ifname) = Self::route_get_info(config.peer().peer_ip)
                .ok()
                .and_then(|info| info.dev)
            {
                eprintln!(
                    "  Ingress NIC auto-detected from route to peer {}: {}",
                    config.peer().peer_ip,
                    peer_ifname
                );
                peer_ifname
            } else if let Some(default_ifname) = Self::default_route_ifname() {
                eprintln!(
                    "  Ingress NIC auto-detected from default route: {}",
                    default_ifname
                );
                default_ifname
            } else {
                eprintln!(
                    "  WARNING: could not auto-detect ingress NIC; falling back to {}",
                    ifname
                );
                ifname.to_string()
            };

        let kernel_version = Self::check_kernel_version()?;
        if kernel_version < (5, 2, 0) {
            return Err(format!(
                "GUT TC eBPF requires kernel >= 5.2 (current: {}.{}.{})",
                kernel_version.0, kernel_version.1, kernel_version.2
            )
            .into());
        }

        let peer_is_v6 = config.peer().peer_ip.is_ipv6();
        let outer_af = if peer_is_v6 { "IPv6" } else { "IPv4" };
        eprintln!("GUT TC eBPF: Initializing (outer {outer_af})");
        eprintln!("  Egress (veth):    {ifname}");
        eprintln!("  Ingress (NIC):    {ingress_ifname}");

        // ── Create veth pair (MACs derived from tunnel IPs, static ARP) ─
        // Use outer_mtu (physical link MTU, e.g. 1500) for veth MTU, NOT the
        // WG inner MTU (e.g. 1420).  WG-encapsulated packets are up to
        // inner_mtu + 28 bytes of WG overhead; if the veth MTU equals the
        // inner MTU, IP forwarding drops or fragments those packets before
        // TC BPF ever sees them — causing 0 throughput on bulk data while
        // small control packets (handshake, keepalive, pings) still pass.
        let veth_xdp_name = format!("{ifname}_xdp");
        let (_local_mac, _xdp_mac) = crate::tun::create_veth_pair(
            ifname,
            &veth_xdp_name,
            config.peer().outer_mtu,
            Some(config.peer().address.as_str()),
        )?;
        eprintln!("  Created veth pair: {veth_xdp_name} ↔ {ifname}");
        let tun_mtu = Self::read_iface_mtu(ifname).ok();
        let xdp_mtu = Self::read_iface_mtu(&veth_xdp_name).ok();
        let tun_gso = Self::read_iface_gso_max_size(ifname).ok();
        let xdp_gso = Self::read_iface_gso_max_size(&veth_xdp_name).ok();
        eprintln!(
            "  Applied link caps: {} mtu={:?} gso_max_size={:?}; {} mtu={:?} gso_max_size={:?} (veth_mtu={}, wg_mtu={})",
            ifname,
            tun_mtu,
            tun_gso,
            veth_xdp_name,
            xdp_mtu,
            xdp_gso,
            config.peer().outer_mtu,
            config.peer().mtu
        );

        let tun_ifindex = Self::get_ifindex(ifname)?;
        let ingress_ifindex = Self::get_ifindex(&ingress_ifname)?;
        let gut_config = Self::build_gut_config(config, ifname, &ingress_ifname)?;
        let gso_target = u32::from(config.peer().mtu);
        Self::set_iface_gso_max_size(ifname, gso_target);
        Self::set_iface_gso_max_size(&veth_xdp_name, gso_target);
        eprintln!(
            "  Applied GSO cap: {}={} {}={} (gso_max_size)",
            ifname, gso_target, veth_xdp_name, gso_target
        );

        // ── Load egress skeleton (v4 or v6 based on peer AF) ────────
        let egress_skel = if peer_is_v6 {
            let builder = tc_gut_egress_v6::TcGutEgressSkelBuilder::default();
            let open_obj: &'static mut MaybeUninit<libbpf_rs::OpenObject> =
                Box::leak(Box::new(MaybeUninit::uninit()));
            let skel = builder.open(open_obj)?.load()?;
            EgressSkel::V6(skel)
        } else {
            let builder = tc_gut_egress::TcGutEgressSkelBuilder::default();
            let open_obj: &'static mut MaybeUninit<libbpf_rs::OpenObject> =
                Box::leak(Box::new(MaybeUninit::uninit()));
            let skel = builder.open(open_obj)?.load()?;
            EgressSkel::V4(skel)
        };

        egress_skel.update_config_map(&gut_config)?;

        // Initialize seq counter (starts at 1 to keep nonce non-zero via Feistel)
        egress_skel.update_counters_map(1)?;

        // Attach TC egress on veth user-side
        let mut tc_builder_egress = TcHookBuilder::new(egress_skel.gut_egress_fd());
        tc_builder_egress
            .ifindex(tun_ifindex)
            .replace(true)
            .handle(1)
            .priority(1);
        let mut egress_hook = tc_builder_egress.hook(libbpf_rs::libbpf_sys::BPF_TC_EGRESS);
        egress_hook.create()?;
        egress_hook.attach()?;
        eprintln!("  TC egress attached on {ifname} (outer {outer_af})");

        // ── Load ingress skeleton (XDP, handles both v4 and v6 outer) ───
        let skel_builder_ingress = xdp_gut_ingress::XdpGutIngressSkelBuilder::default();
        let open_ingress: &'static mut MaybeUninit<libbpf_rs::OpenObject> =
            Box::leak(Box::new(MaybeUninit::uninit()));
        let ingress_skel = skel_builder_ingress.open(open_ingress)?.load()?;

        ingress_skel.maps.config_map.update(
            &0u32.to_ne_bytes(),
            unsafe {
                std::slice::from_raw_parts(
                    (&gut_config as *const GutConfig).cast::<u8>(),
                    std::mem::size_of::<GutConfig>(),
                )
            },
            MapFlags::ANY,
        )?;
        ingress_skel.maps.counters_map.update(
            &0u32.to_ne_bytes(),
            &1u32.to_ne_bytes(),
            MapFlags::ANY,
        )?;

        // Populate devmap with veth_xdp ifindex
        let veth_xdp_ifindex = Self::get_ifindex(&veth_xdp_name)? as u32;
        ingress_skel.maps.tx_devmap.update(
            &0u32.to_ne_bytes(),
            &veth_xdp_ifindex.to_ne_bytes(),
            MapFlags::ANY,
        )?;
        eprintln!("  devmap[0] = {veth_xdp_name} (ifindex={veth_xdp_ifindex})");

        // Attach XDP on NIC (decap + unmask + devmap redirect)
        let xdp_link = ingress_skel
            .progs
            .xdp_gut_ingress
            .attach_xdp(ingress_ifindex)?;

        // Attach XDP_PASS stub on user-facing veth — required for devmap redirect.
        // veth ndo_xdp_xmit checks that the PEER has an XDP program;
        // without this, bpf_redirect_map to gut_xdp silently drops packets.
        let veth_pass_link = ingress_skel.progs.xdp_veth_pass.attach_xdp(tun_ifindex)?;

        let xdp_mode = Self::detect_xdp_mode(&ingress_ifname);
        eprintln!("  XDP ingress on {ingress_ifname} ({xdp_mode}, devmap → {veth_xdp_name})");
        eprintln!("GUT TC eBPF: Successfully attached");

        Ok(Self {
            interface: ifname.to_string(),
            ingress_interface: ingress_ifname,
            egress_skel,
            ingress_skel,
            _egress_hook: egress_hook,
            _xdp_link: xdp_link,
            _veth_pass_link: veth_pass_link,
            _veth_xdp_name: veth_xdp_name,
        })
    }

    /// Detect XDP mode (native/generic) by reading sysfs after attachment.
    #[cfg(target_os = "linux")]
    fn detect_xdp_mode(ifname: &str) -> &'static str {
        // Check /sys/class/net/<ifname>/xdp/mode or parse ip link output
        let path = format!("/sys/class/net/{ifname}/xdp");
        if std::path::Path::new(&path).exists() {
            // If xdp directory exists, XDP is attached
            // Check for drv_prog_id to determine if native
            let drv_path = format!("{path}/drv_prog_id");
            if let Ok(id) = std::fs::read_to_string(&drv_path) {
                let id = id.trim();
                if !id.is_empty() && id != "0" {
                    return "native/DRV";
                }
            }
            let skb_path = format!("{path}/skb_prog_id");
            if let Ok(id) = std::fs::read_to_string(&skb_path) {
                let id = id.trim();
                if !id.is_empty() && id != "0" {
                    return "generic/SKB";
                }
            }
        }
        "unknown"
    }

    #[cfg(not(all(target_os = "linux", feature = "tc_ebpf")))]
    pub fn new(_ifname: &str, _config: &Config) -> Result<Self> {
        Err("TC eBPF is only supported on Linux with tc_ebpf feature".into())
    }

    #[cfg(target_os = "linux")]
    fn get_ifindex(ifname: &str) -> Result<i32> {
        use std::ffi::CString;
        let c_ifname = CString::new(ifname)?;
        let ifindex = unsafe { libc::if_nametoindex(c_ifname.as_ptr()) };
        if ifindex == 0 {
            return Err(format!("Interface {ifname} not found").into());
        }
        Ok(ifindex.cast_signed())
    }

    #[cfg(target_os = "linux")]
    fn check_kernel_version() -> Result<(u32, u32, u32)> {
        use std::ffi::CStr;
        let mut utsname: libc::utsname = unsafe { std::mem::zeroed() };
        if unsafe { libc::uname(&raw mut utsname) } != 0 {
            return Err("Failed to get kernel version".into());
        }
        let release = unsafe { CStr::from_ptr(utsname.release.as_ptr()) }
            .to_str()
            .unwrap_or("0.0.0");
        let parts: Vec<&str> = release.split(&['.', '-'][..]).collect();

        let major = parts
            .first()
            .and_then(|s| s.parse::<u32>().ok())
            .unwrap_or(0);
        let minor = parts
            .get(1)
            .and_then(|s| s.parse::<u32>().ok())
            .unwrap_or(0);
        let patch = parts
            .get(2)
            .and_then(|s| s.parse::<u32>().ok())
            .unwrap_or(0);

        Ok((major, minor, patch))
    }

    #[cfg(target_os = "linux")]
    fn parse_mac(mac: &str) -> Result<[u8; 6]> {
        let mut out = [0u8; 6];
        let parts: Vec<&str> = mac.split(':').collect();
        if parts.len() != 6 {
            return Err(format!("Invalid MAC format: {mac}").into());
        }
        for (idx, part) in parts.iter().enumerate() {
            out[idx] = u8::from_str_radix(part, 16)?;
        }
        Ok(out)
    }

    #[cfg(target_os = "linux")]
    fn read_iface_mac(ifname: &str) -> Result<[u8; 6]> {
        let path = format!("/sys/class/net/{ifname}/address");
        let mac = std::fs::read_to_string(path)?;
        Self::parse_mac(mac.trim())
    }

    #[cfg(target_os = "linux")]
    fn read_iface_mtu(ifname: &str) -> Result<u16> {
        let path = format!("/sys/class/net/{ifname}/mtu");
        let mtu = std::fs::read_to_string(path)?;
        Ok(mtu.trim().parse::<u16>()?)
    }

    #[cfg(target_os = "linux")]
    fn read_iface_gso_max_size(ifname: &str) -> Result<u32> {
        let path = format!("/sys/class/net/{ifname}/gso_max_size");
        let size = std::fs::read_to_string(path)?;
        Ok(size.trim().parse::<u32>()?)
    }

    #[cfg(target_os = "linux")]
    fn set_iface_gso_max_size(ifname: &str, gso_max_size: u32) {
        let _ = std::process::Command::new("ip")
            .args([
                "link",
                "set",
                "dev",
                ifname,
                "gso_max_size",
                &gso_max_size.to_string(),
            ])
            .status();
    }

    #[cfg(target_os = "linux")]
    fn default_route_ifname() -> Option<String> {
        use std::process::Command;

        let output = Command::new("ip")
            .args(["route", "show", "default"])
            .output()
            .ok()?;

        if !output.status.success() {
            return None;
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let line = stdout.lines().next()?;
        let cols: Vec<&str> = line.split_whitespace().collect();
        if let Some(dev_idx) = cols.iter().position(|&c| c == "dev") {
            return cols.get(dev_idx + 1).map(|s| (*s).to_string());
        }
        None
    }

    #[cfg(target_os = "linux")]
    fn route_get_info(peer_ip: std::net::IpAddr) -> Result<RouteGetInfo> {
        use std::process::Command;

        let mut cmd = Command::new("ip");
        match peer_ip {
            std::net::IpAddr::V4(_) => {
                cmd.args(["-4", "route", "get", &peer_ip.to_string()]);
            }
            std::net::IpAddr::V6(_) => {
                cmd.args(["-6", "route", "get", &peer_ip.to_string()]);
            }
        }

        let output = cmd
            .output()
            .map_err(|e| format!("Failed to run 'ip route get': {e}"))?;

        if !output.status.success() {
            return Err(format!("'ip route get {}' failed", peer_ip).into());
        }

        let stdout = String::from_utf8_lossy(&output.stdout);
        let first_line = stdout.lines().next().unwrap_or_default().trim().to_string();
        if first_line.is_empty() {
            return Err(format!("Empty output from 'ip route get {peer_ip}'").into());
        }

        let cols: Vec<&str> = first_line.split_whitespace().collect();
        let dev = cols
            .iter()
            .position(|&c| c == "dev")
            .and_then(|idx| cols.get(idx + 1).map(|s| (*s).to_string()));
        let via = cols
            .iter()
            .position(|&c| c == "via")
            .and_then(|idx| cols.get(idx + 1))
            .and_then(|s| s.parse().ok());
        let src = cols
            .iter()
            .position(|&c| c == "src")
            .and_then(|idx| cols.get(idx + 1))
            .and_then(|s| s.parse().ok());
        let mtu = cols
            .iter()
            .position(|&c| c == "mtu")
            .and_then(|idx| cols.get(idx + 1))
            .and_then(|s| s.parse().ok());

        Ok(RouteGetInfo {
            first_line,
            dev,
            via,
            src,
            mtu,
        })
    }

    #[cfg(target_os = "linux")]
    fn ensure_route_dev(
        peer_ip: std::net::IpAddr,
        ifname: &str,
        info: &RouteGetInfo,
    ) -> Result<()> {
        if let Some(route_dev) = info.dev.as_deref() {
            if route_dev != ifname {
                return Err(
                    format!("Route to {peer_ip} uses dev {route_dev}, expected {ifname}").into(),
                );
            }
        }
        Ok(())
    }

    #[cfg(target_os = "linux")]
    fn resolve_l2_peer_ip(peer_ip: std::net::IpAddr, ifname: &str) -> Result<std::net::IpAddr> {
        let info = Self::route_get_info(peer_ip)?;
        Self::ensure_route_dev(peer_ip, ifname, &info)?;
        Ok(info.via.unwrap_or(peer_ip))
    }

    #[cfg(target_os = "linux")]
    fn resolve_route_src_ip(peer_ip: std::net::IpAddr, ifname: &str) -> Result<std::net::IpAddr> {
        let info = Self::route_get_info(peer_ip)?;
        Self::ensure_route_dev(peer_ip, ifname, &info)?;
        info.src.ok_or_else(|| {
            format!(
                "No 'src' in route lookup for {peer_ip} on {ifname}. Output: {}",
                info.first_line
            )
            .into()
        })
    }

    #[cfg(target_os = "linux")]
    fn resolve_route_pmtu(peer_ip: std::net::IpAddr, ifname: &str) -> Result<u16> {
        let info = Self::route_get_info(peer_ip)?;
        Self::ensure_route_dev(peer_ip, ifname, &info)?;
        info.mtu
            .ok_or_else(|| format!("No explicit route PMTU for {peer_ip} on {ifname}").into())
    }

    #[cfg(target_os = "linux")]
    fn try_probe_neighbor(ip: std::net::IpAddr, ifname: &str) {
        use std::process::{Command, Stdio};

        match ip {
            std::net::IpAddr::V4(ipv4) => {
                let _ = Command::new("ping")
                    .args(["-c", "1", "-W", "1", "-I", ifname, &ipv4.to_string()])
                    .stdout(Stdio::null())
                    .stderr(Stdio::null())
                    .status();
            }
            std::net::IpAddr::V6(ipv6) => {
                let _ = Command::new("ping")
                    .args(["-6", "-c", "1", "-W", "1", "-I", ifname, &ipv6.to_string()])
                    .stdout(Stdio::null())
                    .stderr(Stdio::null())
                    .status();
            }
        }
    }

    #[cfg(target_os = "linux")]
    fn resolve_peer_mac(peer_ip: std::net::IpAddr, ifname: &str) -> Result<[u8; 6]> {
        use std::process::Command;
        let l2_ip = Self::resolve_l2_peer_ip(peer_ip, ifname).unwrap_or(peer_ip);

        for attempt in 0..5 {
            // Use `ip neigh show` which works for both IPv4 (ARP) and IPv6 (NDP)
            let output = Command::new("ip")
                .args(["neigh", "show", &l2_ip.to_string(), "dev", ifname])
                .output()
                .map_err(|e| format!("Failed to run 'ip neigh': {e}"))?;

            let stdout = String::from_utf8_lossy(&output.stdout);
            // Format: "<ip> dev <iface> lladdr <mac> <state>"
            for line in stdout.lines() {
                let cols: Vec<&str> = line.split_whitespace().collect();
                if let Some(idx) = cols.iter().position(|&c| c == "lladdr") {
                    if let Some(mac_str) = cols.get(idx + 1) {
                        return Self::parse_mac(mac_str);
                    }
                }
            }

            if attempt == 0 {
                // Cold neighbor cache on boot/startup is common; actively probe once.
                Self::try_probe_neighbor(l2_ip, ifname);
            }
            std::thread::sleep(std::time::Duration::from_millis(200));
        }

        Err(format!(
            "No neighbor entry for route next-hop {l2_ip} (peer {peer_ip}) on interface {ifname}. \
            Check route with: ip route get {peer_ip}"
        )
        .into())
    }

    #[cfg(target_os = "linux")]
    fn build_gut_config(
        config: &Config,
        tun_ifname: &str,
        ingress_ifname: &str,
    ) -> Result<GutConfig> {
        let mut gut_config = GutConfig::from_config(
            &config.peer().key,
            &config.peer().ports,
            config.peer().peer_ip,
            config.peer().outer_mtu,
        );

        // Set bind address (v4 and/or v6).
        // If wildcard bind is configured (0.0.0.0 / ::), resolve concrete
        // source IP from the route to peer_ip on ingress_ifname.
        match config.peer().bind_ip {
            std::net::IpAddr::V4(ip) => {
                if ip.is_unspecified() {
                    let src = Self::resolve_route_src_ip(config.peer().peer_ip, ingress_ifname)?;
                    match src {
                        std::net::IpAddr::V4(v4) => {
                            gut_config.bind_ip = u32::from_ne_bytes(v4.octets());
                            eprintln!(
                                "  bind_ip auto-resolved: 0.0.0.0 → {} (route src on {})",
                                v4, ingress_ifname
                            );
                        }
                        std::net::IpAddr::V6(v6) => {
                            return Err(format!(
                                "bind_ip=0.0.0.0 but route source resolved to IPv6 {}. \
                                 Set explicit bind_ip or peer_ip family consistently.",
                                v6
                            )
                            .into());
                        }
                    }
                } else {
                    gut_config.bind_ip = u32::from_ne_bytes(ip.octets());
                }
            }
            std::net::IpAddr::V6(ip) => {
                if ip.is_unspecified() {
                    let src = Self::resolve_route_src_ip(config.peer().peer_ip, ingress_ifname)?;
                    match src {
                        std::net::IpAddr::V6(v6) => {
                            gut_config.bind_ip6 = v6.octets();
                            eprintln!(
                                "  bind_ip auto-resolved: :: → {} (route src on {})",
                                v6, ingress_ifname
                            );
                        }
                        std::net::IpAddr::V4(v4) => {
                            return Err(format!(
                                "bind_ip=:: but route source resolved to IPv4 {}. \
                                 Set explicit bind_ip or peer_ip family consistently.",
                                v4
                            )
                            .into());
                        }
                    }
                } else {
                    gut_config.bind_ip6 = ip.octets();
                }
            }
        }
        gut_config.egress_ifindex = Self::get_ifindex(ingress_ifname)? as u32;
        gut_config.tun_ifindex = Self::get_ifindex(tun_ifname)? as u32;
        gut_config.src_mac = Self::read_iface_mac(ingress_ifname)?;
        gut_config.dst_mac = Self::resolve_peer_mac(config.peer().peer_ip, ingress_ifname)?;
        gut_config.tun_mac = Self::read_iface_mac(tun_ifname).unwrap_or([0; 6]);

        // Set default XDP action from config.
        // Safety guard: DROP on the default-route NIC can blackhole host traffic
        // (including SSH). Auto-downgrade to PASS in that case.
        gut_config.default_xdp_action = match config.peer().default_policy {
            crate::config::XdpDefaultPolicy::Allow => 0, // XDP_PASS
            crate::config::XdpDefaultPolicy::Drop => 1,  // XDP_DROP
        };
        gut_config.keepalive_drop_percent = config.peer().keepalive_drop_percent;

        if gut_config.default_xdp_action == 1 {
            if let Some(default_ifname) = Self::default_route_ifname() {
                if default_ifname == ingress_ifname {
                    eprintln!(
                        "WARNING: default_policy=drop on ingress NIC '{}' (default route). \
                         Without this guard, all non-GUT ingress traffic on this NIC would be dropped \
                         (including SSH/management). For safety, overriding to allow.",
                        ingress_ifname
                    );
                    DROP_POLICY_SAFETY_OVERRIDES.fetch_add(1, Ordering::Relaxed);
                    gut_config.default_xdp_action = 0;
                }
            }
        }

        let route_pmtu = Self::resolve_route_pmtu(config.peer().peer_ip, ingress_ifname).ok();
        let ingress_mtu = Self::read_iface_mtu(ingress_ifname).ok();
        let pmtu_base = route_pmtu
            .or(ingress_mtu)
            .unwrap_or(config.peer().outer_mtu);
        gut_config.outer_mtu = pmtu_base;
        let computed_v4 = pmtu_base.saturating_sub(OUTER_OVERHEAD_IPV4);
        let computed_v6 = pmtu_base.saturating_sub(OUTER_OVERHEAD_IPV6);
        gut_config.inner_mtu_v4 = if computed_v4 == 0 {
            DEFAULT_INNER_MTU
        } else {
            computed_v4
        };
        gut_config.inner_mtu_v6 = if computed_v6 == 0 {
            DEFAULT_INNER_MTU
        } else {
            computed_v6
        };
        let inner_v4 = gut_config.inner_mtu_v4;
        let inner_v6 = gut_config.inner_mtu_v6;
        let wg_data_overhead: u16 = 32;
        let wg_rec_v4 = inner_v4.saturating_sub(wg_data_overhead);
        let wg_rec_v6 = inner_v6.saturating_sub(wg_data_overhead);

        eprintln!(
            "GUT TC eBPF PMTU: base={} inner_v4={} inner_v6={} (base=route_pmtu|if_mtu|config_outer_mtu)",
            pmtu_base, inner_v4, inner_v6
        );
        eprintln!(
            "GUT TC eBPF WG MTU recommendation: ipv4={} ipv6={} (WG data overhead=32, payload-only mode)",
            wg_rec_v4, wg_rec_v6
        );

        gut_config.offload_flags = Self::probe_offload_flags(tun_ifname);

        // Partial IP checksum only meaningful for outer IPv4
        if config.peer().peer_ip.is_ipv4() {
            gut_config.compute_partial_ip_csum();
        }

        // Populate tunnel veth IPs for XDP ingress IP rewrite.
        // XDP rewrites outer src/dst back to gut0 IPs so WireGuard does not
        // roam to the real remote IP after receiving the first ingress packet.
        match crate::tun::compute_p2p_peer(&config.peer().address) {
            Ok((local_ip_str, peer_ip_str, _)) => {
                match (
                    local_ip_str.parse::<std::net::Ipv4Addr>(),
                    peer_ip_str.parse::<std::net::Ipv4Addr>(),
                ) {
                    (Ok(local_ip), Ok(peer_ip)) => {
                        gut_config.tun_local_ip4 = u32::from_ne_bytes(local_ip.octets());
                        gut_config.tun_peer_ip4 = u32::from_ne_bytes(peer_ip.octets());
                        eprintln!(
                            "  XDP ingress IP rewrite: src={} dst={} (tun_peer → tun_local)",
                            peer_ip, local_ip
                        );
                    }
                    _ => {
                        eprintln!(
                            "  WARNING: XDP ingress IP rewrite disabled \
                             (address={} is IPv6 or unparseable)",
                            config.peer().address
                        );
                    }
                }
            }
            Err(e) => {
                eprintln!(
                    "  WARNING: XDP ingress IP rewrite disabled \
                     (compute_p2p_peer failed: {e})"
                );
            }
        }

        Ok(gut_config)
    }

    #[cfg(target_os = "linux")]
    fn probe_offload_flags(ifname: &str) -> u16 {
        let disable_l4_csum = std::env::var("GUTD_FORCE_L4_CSUM")
            .ok()
            .map(|v| matches!(v.as_str(), "0" | "false" | "no" | "off"))
            .unwrap_or(false);

        if disable_l4_csum {
            eprintln!(
                "  offloads: {ifname} \u{2192} forced inner L4 finalize disabled (GUTD_FORCE_L4_CSUM=0)"
            );
            0
        } else {
            eprintln!(
                "  offloads: {ifname} \u{2192} BPF finalizes inner L4 checksum (default); \
                 set GUTD_FORCE_L4_CSUM=0 only for troubleshooting"
            );
            GUT_FLAG_NEED_L4_CSUM
        }
    }

    #[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
    pub fn update_config(&mut self, config: &Config) -> Result<()> {
        let gut_config = Self::build_gut_config(config, &self.interface, &self.ingress_interface)?;

        self.egress_skel.update_config_map(&gut_config)?;

        self.ingress_skel.maps.config_map.update(
            &0u32.to_ne_bytes(),
            unsafe {
                std::slice::from_raw_parts(
                    (&gut_config as *const GutConfig).cast::<u8>(),
                    std::mem::size_of::<GutConfig>(),
                )
            },
            MapFlags::ANY,
        )?;

        let outer_af = if self.egress_skel.is_v6() {
            "IPv6"
        } else {
            "IPv4"
        };
        eprintln!(
            "GUT TC eBPF: Config reloaded (egress={}, ingress={}, outer={})",
            self.interface, self.ingress_interface, outer_af
        );
        Ok(())
    }

    #[cfg(not(all(target_os = "linux", feature = "tc_ebpf")))]
    pub fn update_config(&mut self, _config: &Config) -> Result<()> {
        Err("TC eBPF not available on this platform".into())
    }

    #[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
    pub fn get_stats(&self) -> Result<TcStats> {
        let key = 0u32.to_ne_bytes();
        let value_size = std::mem::size_of::<GutStats>();

        let egress = match self.egress_skel.lookup_stats(&key)? {
            Some(per_cpu) => Self::parse_percpu_stats(&per_cpu, value_size),
            None => GutStats::default(),
        };

        let ingress = match self
            .ingress_skel
            .maps
            .stats_map
            .lookup_percpu(&key, MapFlags::ANY)?
        {
            Some(per_cpu) => Self::parse_percpu_stats(&per_cpu, value_size),
            None => GutStats::default(),
        };

        Ok(TcStats { egress, ingress })
    }

    /// Parse per-CPU values returned by `lookup_percpu()`. Returns aggregated stats.
    #[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
    fn parse_percpu_stats(per_cpu_data: &[Vec<u8>], value_size: usize) -> GutStats {
        let mut per_cpu = Vec::with_capacity(per_cpu_data.len());
        for cpu_data in per_cpu_data {
            if cpu_data.len() >= value_size {
                let mut stats = GutStats::default();
                unsafe {
                    std::ptr::copy_nonoverlapping(
                        cpu_data.as_ptr(),
                        (&raw mut stats).cast::<u8>(),
                        value_size,
                    );
                }
                per_cpu.push(stats);
            }
        }
        GutStats::aggregate(&per_cpu)
    }

    #[cfg(not(all(target_os = "linux", feature = "tc_ebpf")))]
    pub fn get_stats(&self) -> Result<TcStats> {
        Ok(TcStats::default())
    }

    #[must_use]
    pub fn interface(&self) -> &str {
        &self.interface
    }
}

impl Drop for TcBpfManager {
    fn drop(&mut self) {
        eprintln!(
            "GUT TC eBPF: Detaching (egress={}, ingress={})",
            self.interface, self.ingress_interface,
        );

        #[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
        {
            eprintln!("  Destroying veth pair: {}", self._veth_xdp_name);
            crate::tun::destroy_veth(&self._veth_xdp_name);
        }
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    #[cfg(target_os = "linux")]
    fn test_kernel_version() {
        let version = TcBpfManager::check_kernel_version().unwrap();
        eprintln!("Kernel version: {}.{}.{}", version.0, version.1, version.2);
        assert!(version.0 >= 4);
    }

    #[test]
    fn test_deterministic_mac_generation() {
        let mac1 = crate::tun::mac_from_ipv4("10.0.0.1").unwrap();
        let mac2 = crate::tun::mac_from_ipv4("10.0.0.1").unwrap();

        // Deterministic: same input → same output
        assert_eq!(mac1, mac2);

        // Locally-administered bit set
        assert_eq!(mac1[0] & 0x02, 0x02);

        // Unicast (multicast bit clear)
        assert_eq!(mac1[0] & 0x01, 0x00);

        // GUT marker byte
        assert_eq!(mac1[1], 0x47);

        // IP octets embedded directly
        assert_eq!(mac1, [0x02, 0x47, 10, 0, 0, 1]);

        // Different IPs → different MACs
        let mac3 = crate::tun::mac_from_ipv4("10.0.0.2").unwrap();
        assert_ne!(mac1, mac3);

        eprintln!(
            "MAC 10.0.0.1: {} | MAC 10.0.0.2: {}",
            crate::tun::mac_to_string(&mac1),
            crate::tun::mac_to_string(&mac3)
        );
    }

    #[test]
    #[cfg(all(target_os = "linux", feature = "tc_ebpf"))]
    fn test_gut_v1_protocol() {
        eprintln!("GUT v1 Protocol - TC eBPF fast path enabled");
        eprintln!("Wire format: UDP payload = nonce(u32) || masked_body || cookie(u8)");
    }
}
